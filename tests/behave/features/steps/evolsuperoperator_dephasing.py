"""

    Autogenerated by ghenerate script, part of Quantarhei
    http://github.com/tmancal74/quantarhei
    Tomas Mancal, tmancal74@gmai.com

    Generated on: 2018-11-07 09:41:47

    Edit the functions below to give them desired functionality.
    In present version of `ghenerate`, no edits or replacements
    are perfomed in the feature file text.

"""

from behave import given
from behave import when
from behave import then

import numpy

import quantarhei as qr

#
# Given ...
#
@given('I have PureDephasing object D with dephasing time {dtime} and initial density matrix R')
def step_given_1(context, dtime):
    """

        Given I have PureDephasing object D with dephasing time {dtime} and initial density matrix R

    """
    td = float(dtime)
    print("Dephasing time", td)
    context.td = td

    # create test aggregatedimer
    agg = qr.TestAggregate("trimer-2")
    with qr.energy_units("1/cm"):
        agg.set_resonance_coupling(0,1,100.0)
        agg.set_resonance_coupling(1,2,50.0)
    agg.build()
    

    
    HH = agg.get_Hamiltonian()
    context.H = HH
    
    print("Hamiltonian:")
    print(HH)
    
    # initial density matrix
    R = qr.ReducedDensityMatrix(dim=HH.dim)
    with qr.eigenbasis_of(HH):
        R.data[1:4,1:4] = 0.5

    
    context.R = R
    
    dd = numpy.zeros((4,4), dtype=qr.REAL)
    dd[1,2] = 1.0/td
    dd[2,1] = 1.0/td
    dd[1,3] = 1.0/td
    dd[3,1] = 1.0/td
    dd[2,3] = 1.0/td
    dd[3,2] = 1.0/td
    D = qr.qm.PureDephasing(drates=dd)
    
    context.D = D
    
#
# When ...
#
@when('I calculate EvolutionSuperOperator using only PureDephasing D with {time_step} and {N_dense}')
def step_when_2(context, time_step, N_dense):
    """

        When I calculate EvolutionSuperOperator using only PureDephasing D with {time_step} and {N_dense}

    """
    # get the associated time axis and the relaxation tensor and Hamiltonian
    dt = float(time_step)
    N_dense = int(N_dense)
    
    time = qr.TimeAxis(0, 1320, 1.0)
    time2 = qr.TimeAxis(0, 132, dt)
    context.time = time
    context.time2 = time2
    
    HH = context.H
    DD = context.D

    print("Dephasing type: ", DD.dtype)
   
    # This tests if it is possible to ignore relaxation tensor in defining
    # evolution superoperator
    L =  qr.qm.LindbladForm(HH, sbi=None)
    
    U = qr.qm.EvolutionSuperOperator(time2, ham=HH, relt=L, pdeph=DD)
    U.set_dense_dt(N_dense)
    
    with qr.eigenbasis_of(HH):
        U.calculate()
    
    context.U = U


#
# And ...
#
@when('I apply the EvolutionSuperOperator to R to get RD at time {t_prop}')
def step_when_3(context, t_prop):
    """

        And I apply the EvolutionSuperOperator to R to get RD

    """
    U = context.U
    R = context.R
    
    t = float(t_prop)

    RD = U.apply(t, R)


    context.RD = RD


#
# And ...
#
@when('I multiply each coherence element by corresponding exponential decay with dephasing time {dtime} to get RE at time {t_prop}')
def step_when_4(context, dtime, t_prop):
    """

        And I multiply each coherence element by corresponding exponential decay with dephasing time {dtime} to get RE

    """
    gamma = 1.0/float(dtime)
    t = float(t_prop)

    R = context.R
    
    HH = context.H
    
    RE = qr.ReducedDensityMatrix(dim=HH.dim)
    RE.data[:,:] = 0.0
    with qr.eigenbasis_of(HH):
        for i in range(4):
            for j in range(4):
                om = HH.data[i,i]-HH.data[j,j]
                if i != j:
                    RE.data[i,j] = R.data[i,j]*numpy.exp(-1j*om*t -gamma*t)
                else:
                    RE.data[i,j] = R.data[i,j]*numpy.exp(-1j*om*t)
        
    context.RE = RE


#
# Then ...
#
@then('RD equals RE at times {t_prop}')
def step_then_5(context, t_prop):
    """

        Then RD equals RE at times {t_prop}

    """
    RD = context.RD
    RE = context.RE
    
    with qr.eigenbasis_of(context.H):
        print(context.R)
        print("\nCalculated with U:")
        print("Shape: ", RD.data.shape)
        print(RD.data)
        print("\nReference calculation:")
        print("Shape: ", RE.data.shape)
        print(RE.data)
    
        print("\nMax diff:", numpy.amax(numpy.abs(RD.data - RE.data)))
        
        numpy.testing.assert_allclose(RD.data, RE.data, rtol=1.0e-5,
                                          atol=1.0e-5)

#
# Given ...
#
@given('I have PureDephasing object D with dephasing constant {dtime} and initial density matrix R')
def step_given_6(context, dtime):
    """

        Given I have PureDephasing object D with dephasing constant {dtime} and initial density matrix R

    """
    td = float(dtime)
    print("Dephasing time", td)
    context.td = td

    # create test aggregatedimer
    agg = qr.TestAggregate("trimer-2")
    with qr.energy_units("1/cm"):
        agg.set_resonance_coupling(0,1,100.0)
        agg.set_resonance_coupling(1,2,50.0)
    agg.build()
    

    
    HH = agg.get_Hamiltonian()
    context.H = HH
    
    print("Hamiltonian:")
    print(HH)
    
    # initial density matrix
    R = qr.ReducedDensityMatrix(dim=HH.dim)
    with qr.eigenbasis_of(HH):
        R.data[1:4,1:4] = 0.5

    
    context.R = R
    
    dd = numpy.zeros((4,4), dtype=qr.REAL)
    dd[1,2] = (1.0/td)**2
    dd[2,1] = (1.0/td)**2
    dd[1,3] = (1.0/td)**2
    dd[3,1] = (1.0/td)**2
    dd[2,3] = (1.0/td)**2
    dd[3,2] = (1.0/td)**2
    D = qr.qm.PureDephasing(drates=dd, dtype="Gaussian")
    
    context.D = D


#
# And ...
#
@when('I multiply each coherence element by corresponding Gaussian decay with dephasing time {dtime} to get RE at time {t_prop}')
def step_when_7(context, dtime, t_prop):
    """

        And I multiply each coherence element by corresponding Gaussian decay with dephasing time {dtime} to get RE at time {t_prop}

    """
    delta = (1.0/float(dtime))**2
    t = float(t_prop)

    R = context.R
    
    HH = context.H
    
    RE = qr.ReducedDensityMatrix(dim=HH.dim)
    RE.data[:,:] = 0.0
    with qr.eigenbasis_of(HH):
        for i in range(4):
            for j in range(4):
                om = HH.data[i,i]-HH.data[j,j]
                if i != j:
                    RE.data[i,j] = R.data[i,j]*numpy.exp(-1j*om*t -(delta/2.0)*(t**2))
                else:
                    RE.data[i,j] = R.data[i,j]*numpy.exp(-1j*om*t)
        
    context.RE = RE
    
    
#
# When ...
#
@when('I calculate EvolutionSuperOperator step by step using only PureDephasing D with {time_step} and {N_dense}')
def step_when_8(context, time_step, N_dense):
    """

        When I calculate EvolutionSuperOperator step by step using only PureDephasing D with {time_step} and {N_dense} 

    """
    # get the associated time axis and the relaxation tensor and Hamiltonian
    dt = float(time_step)
    N_dense = int(N_dense)
    
    Ntot = 1320
    Nsteps = int(Ntot/N_dense)
    time = qr.TimeAxis(0, Ntot, 1.0)
    time2 = qr.TimeAxis(0, Nsteps, dt)
    context.time = time
    context.time2 = time2
    
    HH = context.H
    DD = context.D
    
    print("Dephasing type: ", DD.dtype)
   
    # This tests if it is possible to ignore relaxation tensor in defining
    # evolution superoperator
    L =  qr.qm.LindbladForm(HH, sbi=None)
    
    U = qr.qm.EvolutionSuperOperator(time2, ham=HH, relt=L, 
                                     pdeph=DD, mode="jit")
    U.set_dense_dt(N_dense)
    
    U1 = qr.qm.EvolutionSuperOperator(time2, ham=HH, relt=L, 
                                     pdeph=DD)
    
    with qr.eigenbasis_of(HH):
        
        for i in range(1, Nsteps):
            U.calculate_next()
            U1.data[i,:,:,:,:] = U.data[:,:,:,:]
            
    context.U = U1


#
# Given ...
#
@given('I have a Hamiltonian H, Lidblad form L, PureDephasing object D with dephasing constant {dtime} and initial density matrix R')
def step_given_9(context, dtime):
    """

        Given I have a Hamiltonian H, Lidblad form L, PureDephasing object D with dephasing constant {dtime} and initial density matrix R

    """
    td = float(dtime)
    print("Dephasing time", td)
    context.td = td

    # create test aggregatedimer
    agg = qr.TestAggregate("trimer-2")
    with qr.energy_units("1/cm"):
        agg.set_resonance_coupling(0,1,100.0)
        agg.set_resonance_coupling(1,2,50.0)
    agg.build()
    

    
    HH = agg.get_Hamiltonian()
    context.H = HH
    
    print("Hamiltonian:")
    print(HH)
    
    L =  qr.qm.LindbladForm(HH, sbi=None)
    
    context.L = L
    
    # initial density matrix
    R = qr.ReducedDensityMatrix(dim=HH.dim)
    with qr.eigenbasis_of(HH):
        R.data[1:4,1:4] = 0.5

    
    context.R = R
    
    dd = numpy.zeros((4,4), dtype=qr.REAL)
    dd[1,2] = 1.0/td
    dd[2,1] = 1.0/td
    dd[1,3] = 1.0/td
    dd[3,1] = 1.0/td
    dd[2,3] = 1.0/td
    dd[3,2] = 1.0/td
    D = qr.qm.PureDephasing(drates=dd, dtype="Gaussian")
    
    context.D = D


#
# When ...
#
@when('I calculate EvolutionSuperOperator step by step using PureDephasing D and Lindblad form L with {time_step} and {N_dense}')
def step_when_10(context, time_step, N_dense):
    """

        When I calculate EvolutionSuperOperator step by step using PureDephasing D and Lindblad form L with {time_step} and {N_dense}

    """
    HH = context.H
    L = context.L
    DD = context.D

    dt = float(time_step)
    N_dense = int(N_dense)
    Ntot = 1320
    Nsteps = int(Ntot/N_dense)

    time2 = qr.TimeAxis(0, Nsteps, dt)
    context.time2 = time2

    mode = "jit"
    print("Pure dephasing: ", DD.dtype)
    
    if mode == "jit":

        U = qr.qm.EvolutionSuperOperator(time2, ham=HH, relt=L, 
                                         pdeph=DD, mode="jit")
        U.set_dense_dt(N_dense)
        
        U1 = qr.qm.EvolutionSuperOperator(time2, ham=HH, relt=L, 
                                         pdeph=DD)
        
        with qr.eigenbasis_of(HH):
            
            for i in range(1, Nsteps):
                U.calculate_next()
                U1.data[i,:,:,:,:] = U.data[:,:,:,:]
                
        context.U = U1

    elif mode == "all":
        
        U = qr.qm.EvolutionSuperOperator(time2, ham=HH, relt=L, 
                                         pdeph=DD, mode="all")
        U.set_dense_dt(N_dense)   
        
        with qr.eigenbasis_of(HH):
                U.calculate()

        context.U = U

#
# And ...
#
@when('I propagate with Lindblad form L and PureDephasing D to get RE at time {t_prop}')
def step_when_11(context, t_prop):
    """

        And I propagate with Lindblad form L and PureDephasing D to get RE at time {t_prop}

    """

    t = float(t_prop)

    # initial density matrix
    R = context.R
    
    HH = context.H
    
    RE = qr.ReducedDensityMatrix(dim=HH.dim)
    RE.data[:,:] = 0.0

    time2 = context.time2
    t2, dt2 = time2.locate(t)
    
    L = context.L
    D = context.D
    
    prop = qr.ReducedDensityMatrixPropagator(timeaxis=time2,
                                             Ham=HH, RTensor=L, PDeph=D)
    prop.setDtRefinement(10)
    
    with qr.eigenbasis_of(HH):
        rhot = prop.propagate(R)
    
    RE = qr.ReducedDensityMatrix(data=rhot.data[t2,:,:])
        
    context.RE = RE


#
# When ...
#
@when('I calculate EvolutionSuperOperator in one shot using only PureDephasing D with {time_step} and {N_dense}')
def step_when_12(context, time_step, N_dense):
    """

        When I calculate EvolutionSuperOperator in one shot using only PureDephasing D with {time_step} and {N_dense}

    """
    HH = context.H
    L = qr.qm.LindbladForm(HH, sbi=None)
    DD = context.D

    dt = float(time_step)
    N_dense = int(N_dense)
    Ntot = 1320
    Nsteps = int(Ntot/N_dense)

    time2 = qr.TimeAxis(0, Nsteps, dt)
    context.time2 = time2

    mode = "all"
    U = qr.qm.EvolutionSuperOperator(time2, ham=HH, relt=L, 
                                     pdeph=DD, mode=mode)
    U.set_dense_dt(N_dense)
    
    if mode == "all":
        with qr.eigenbasis_of(HH):
            U.calculate()
                
        context.U = U

    elif mode == "jit":
        U1 = qr.qm.EvolutionSuperOperator(time2, ham=HH, relt=L, 
                                         pdeph=DD)
        
        with qr.eigenbasis_of(HH):
            
            for i in range(1, Nsteps):
                U.calculate_next()
                U1.data[i,:,:,:,:] = U.data[:,:,:,:]
                
        context.U = U1
        
    #
# When ...
#
@when('I calculate EvolutionSuperOperator in one shot using PureDephasing D and Lindblad form L with {time_step} and {N_dense}')
def step_when_13(context, time_step, N_dense):
    """

        When I calculate EvolutionSuperOperator in one shot using PureDephasing D and Lindblad form L with {time_step} and {N_dense}

    """
    HH = context.H
    L = context.L
    DD = context.D

    dt = float(time_step)
    N_dense = int(N_dense)
    Ntot = 1320
    Nsteps = int(Ntot/N_dense)

    time2 = qr.TimeAxis(0, Nsteps, dt)
    context.time2 = time2

    mode = "all"
    U = qr.qm.EvolutionSuperOperator(time2, ham=HH, relt=L, 
                                     pdeph=DD, mode=mode)
    U.set_dense_dt(N_dense)
    
    if mode == "all":
        with qr.eigenbasis_of(HH):
            U.calculate()
                
        context.U = U

    elif mode == "jit":
        U1 = qr.qm.EvolutionSuperOperator(time2, ham=HH, relt=L, 
                                         pdeph=DD)
        
        with qr.eigenbasis_of(HH):
            
            for i in range(1, Nsteps):
                U.calculate_next()
                U1.data[i,:,:,:,:] = U.data[:,:,:,:]
                
        context.U = U1
        
#
# Given ...
#
@given('I have a Hamiltonian H, Lidblad form L, PureDephasing object D with dephasing time {dtime} and initial density matrix R')
def step_given_14(context, dtime):
    """

        Given I have a Hamiltonian H, Lidblad form L, PureDephasing object D with dephasing time {dtime} and initial density matrix R

    """
    td = float(dtime)
    print("Dephasing time", td)
    context.td = td

    # create test aggregatedimer
    agg = qr.TestAggregate("trimer-2")
    with qr.energy_units("1/cm"):
        agg.set_resonance_coupling(0,1,100.0)
        agg.set_resonance_coupling(1,2,50.0)
    agg.build()
    

    
    HH = agg.get_Hamiltonian()
    context.H = HH
    
    print("Hamiltonian:")
    print(HH)
    
    L =  qr.qm.LindbladForm(HH, sbi=None)
    
    context.L = L
    
    # initial density matrix
    R = qr.ReducedDensityMatrix(dim=HH.dim)
    with qr.eigenbasis_of(HH):
        R.data[1:4,1:4] = 0.5

    
    context.R = R
    
    dd = numpy.zeros((4,4), dtype=qr.REAL)
    dd[1,2] = 1.0/td
    dd[2,1] = 1.0/td
    dd[1,3] = 1.0/td
    dd[3,1] = 1.0/td
    dd[2,3] = 1.0/td
    dd[3,2] = 1.0/td
    D = qr.qm.PureDephasing(drates=dd, dtype="Lorentzian")
    
    context.D = D