"""

    Autogenerated by ghenerate script, part of Quantarhei
    http://github.com/tmancal74/quantarhei
    Tomas Mancal, tmancal74@gmai.com

    Generated on: 2018-06-07 12:26:28

    Edit the functions below to give them desired functionality.
    In present version of `ghenerate`, no edits or replacements
    are perfomed in the feature file text.

"""
import numpy

from behave import given
from behave import when
from behave import then

import quantarhei as qr

#
# Given ...
#
@given('that I have {N} TwoDResponse objects')
def step_given_1(context, N):
    """

        Given that I have {N} TwoDResponse objects

    """
    spectra = []
    ids = []
    
    for i_n in range(int(N)):
        spec = qr.TwoDResponse()
        itsid = id(spec)
        spectra.append(spec)
        ids.append(itsid)
        
    context.spectra = spectra
    context.ids = ids


#
# And ...
#
@given('I have an empty TwoDResponse container')
def step_given_2(context):
    """

        And I have an empty TwoDResponse container

    """
    container = qr.TwoDResponseContainer()
    context.container = container


#
# When ...
#
@when('I set the container to accept indexing by integers')
def step_when_3(context):
    """

        When I set the container to accept indexing by integers

    """
    cont = context.container
    
    cont.use_indexing_type("integer")


#
# And ...
#
@when('I add the spectra to the container one by one')
def step_when_4(context):
    """

        And I add the spectra to the container one by one

    """
    cont = context.container
    for spect in context.spectra:
        cont.set_spectrum(spect)


#
# Then ...
#
@then('TwoDResponse can be retrieved using the index {i}')
def step_then_5(context, i):
    """

        Then TwoDResponse can be retrieved using the index {i}

    """
    ids = context.ids
    cont = context.container
    
    length = len(ids)
    
    i_n = int(i)
    
    context.out_of_range = 0
    if i_n >= length:
        context.out_of_range = i_n
        return

    if not (ids[i_n] == id(cont.get_spectrum_by_index(i_n))):
        raise Exception("Incorrect retrieval of spectrum from container")


#
# But ...
#
@then('when index is out of bounds, I get an exception')
def step_then_6(context):
    """

        But when index is out of bounds, I get an exception

    """
    i_n = context.out_of_range
    if  i_n > 0:
        
        cont = context.container
        try:
            
            cont.get_spectrum_by_index(i_n)
            
        except KeyError as e:
            print(e, str(i_n)) # "'"+str(i_n)+"'")
            assert str(e) == str(i_n) #"'"+str(i_n)+"'"
            
        except IndexError as e:
            print(e, "list index out of range")
            assert str(e) ==  "list index out of range"           
 
#
# And ...
#
@given('I have a ValueAxis of lenght {N} starting from zero with certain {step}')
def step_given_7(context, N, step):
    """

        And I have a ValueAxis of lenght {N} starting from zero with certain {step}

    """
    length = int(N)
    step = float(step)
    vaxis = qr.ValueAxis(0.0, length, step)
    
    context.vaxis = vaxis
    context.length = length
    context.step = step


#
# When ...
#
@when('I set the container to accept index by ValueAxis')
def step_when_8(context):
    """

        When I set the container to accept index by ValueAxis

    """
    cont = context.container
    vaxis = context.vaxis
    
    cont.use_indexing_type(vaxis)


#
# And ...
#
@when('I add the spectra to the container using values from ValueAxis')
def step_when_9(context):
    """

        And I add the spectra to the container using values from ValueAxis

    """
    cont = context.container
    spectra = context.spectra
    
    i_n = 0
    for val in context.vaxis.data:
        cont.set_spectrum(spectra[i_n], tag=val)
        i_n += 1
        


#
# Then ...
#
@then('TwoDResponse can be retrieved using values {val} from ValueAxis')
def step_then_10(context, val):
    """

        Then TwoDResponse can be retrieved using values {val} from ValueAxis

    """
    cont = context.container
    vaxis = context.vaxis
    
    context.out_of_range = 0
    
    vmax = vaxis.max
    
    if (float(val) < vmax):

        cont.get_spectrum(float(val))

    else:

        context.out_of_range=float(val)
        


#
# But ...
#
@then('when values are out of bounds, I get an exception')
def step_then_11(context):
    """

        But when values are out of bounds, I get an exception

    """
    val = context.out_of_range
    
    if val > 0:

        cont = context.container
        try:
            
            cont.get_spectrum(val)
            
        except Exception as e:
            assert str(e) == "Tag not compatible with the ValueAxis"        
        
#
# And ...
#
@given('I have a TimeAxis of lenght {N} starting from zero with certain {step}')
def step_given_12(context, N, step):
    """

        And I have a TimeAxis of lenght {N} starting from zero with certain {step}

    """
    length = int(N)
    step = float(step)
    vaxis = qr.TimeAxis(0.0, length, step)
    
    context.vaxis = vaxis
    context.length = length
    context.step = step

#
# When ...
#
@when('I set the container to accept index by TimeAxis')
def step_when_13(context):
    """

        When I set the container to accept index by TimeAxis

    """
    cont = context.container
    vaxis = context.vaxis
    
    cont.use_indexing_type(vaxis)


#
# And ...
#
@when('I add the spectra to the container using values from TimeAxis')
def step_when_14(context):
    """

        And I add the spectra to the container using values from TimeAxis

    """
    cont = context.container
    spectra = context.spectra
    
    i_n = 0
    for val in context.vaxis.data:
        cont.set_spectrum(spectra[i_n], tag=val)
        i_n += 1


#
# Then ...
#
@then('TwoDResponse can be retrieved using values {val} from TimeAxis')
def step_then_15(context, val):
    """

        Then TwoDResponse can be retrieved using values {val} from TimeAxis

    """
    cont = context.container
    vaxis = context.vaxis
    
    context.out_of_range = 0
    
    vmax = vaxis.max
    
    if (float(val) < vmax):

        cont.get_spectrum(float(val))

    else:

        context.out_of_range=float(val)

#
# And ...
#
@given('I have a FrequencyAxis of lenght {N} starting from zero with certain {step}')
def step_given_16(context, N, step):
    """

        And I have a FrequencyAxis of lenght {N} starting from zero with certain {step}

    """
    length = int(N)
    step = float(step)
    vaxis = qr.FrequencyAxis(0.0, length, step)
    
    context.vaxis = vaxis
    context.length = length
    context.step = step


#
# When ...
#
@when('I set the container to accept index by FrequencyAxis')
def step_when_17(context):
    """

        When I set the container to accept index by FrequencyAxis

    """
    cont = context.container
    vaxis = context.vaxis
    
    cont.use_indexing_type(vaxis)


#
# And ...
#
@when('I add the spectra to the container using values from FrequencyAxis')
def step_when_18(context):
    """

        And I add the spectra to the container using values from FrequencyAxis

    """
    cont = context.container
    spectra = context.spectra
    
    i_n = 0
    for val in context.vaxis.data:
        cont.set_spectrum(spectra[i_n], tag=val)
        i_n += 1


#
# Then ...
#
@then('TwoDResponse can be retrieved using values {val} from FrequencyAxis')
def step_then_19(context, val):
    """

        Then TwoDResponse can be retrieved using values {val} from FrequencyAxis

    """
    cont = context.container
    vaxis = context.vaxis
    
    context.out_of_range = 0
    
    vmax = vaxis.max
    
    if (float(val) < vmax):

        cont.get_spectrum(float(val))

    else:

        context.out_of_range=float(val)

#
# And ...
#
@given('I have a list of strings of lenght {N}')
def step_given_20(context, N):
    """

        And I have a list of strings of lenght {N}

    """
    strlist = []
    Nn = int(N)
    for k_n in range(Nn):
        strng = "string_"+str(k_n)
        strlist.append(strng)
        
    context.strlist = strlist


#
# When ...
#
@when('I set the container to accept index by strings')
def step_when_21(context):
    """

        When I set the container to accept index by strings

    """
    cont = context.container
    
    cont.use_indexing_type("string")


#
# And ...
#
@when('I add the spectra to the container using values from the list of strings')
def step_when_22(context):
    """

        And I add the spectra to the container using values from the list of strings

    """
    cont = context.container
    
    k_i = 0
    for strng in context.strlist:
        spect = context.spectra[k_i]
        cont.set_spectrum(spect, tag=strng)
        k_i += 1



#
# Then ...
#
@then('TwoDResponse can be retrieved using values from the list of strings')
def step_then_23(context):
    """

        Then TwoDResponse can be retrieved using values from the list of strings

    """
    
    cont = context.container
    
    for strng in context.strlist:
        
        cont.get_spectrum(strng)    


#
# But ...
#
@then('when values are not in the list of strings, I get an exception')
def step_then_24(context):
    """

        But when values are not in the list of strings, I get an exception

    """
    cont = context.container
    try:
        
        cont.get_spectrum("ahoj")
        
    except KeyError as e:
        assert str(e) == "'ahoj'"


###############################################################################
#
#  Fourier transform
#
###############################################################################
      

def _container(context, N, cls):

    import numpy
    
    Nn = int(N)
    
    spectra = []
    
    def func(x,y,t):
        
        Delta = 10.0
        omega = 2.0*3.14159/20.0 
        gamma = 1.0/100.0
        
        data = numpy.zeros((len(x), len(y)))
        
        for i_x in range(len(x)):
                data[i_x, :] = numpy.exp(-((x[i_x]+y)/Delta)**2)* \
                                    numpy.cos(omega*t)*numpy.exp(-t/gamma)
        
        return data

    time = cls(0.0, Nn, 2.0)
    xrange = qr.ValueAxis(-50.0, 100, 1.0)
    yrange = qr.ValueAxis(-50.0, 100, 1.0)
    
    cont = qr.TwoDResponseContainer()
    cont.use_indexing_type(time)
    
    for k_n in range(Nn):
        tt = time.data[k_n]
        data = func(xrange.data, yrange.data, tt)
        spect = qr.TwoDResponse()
        spect.set_resolution("off")
        spect.set_data_flag(qr.signal_TOTL)
        
        #spect.set_data(data)
        spect._add_data(data, dtype=qr.signal_TOTL)
        
        spect.set_axis_1(xrange)
        spect.set_axis_3(yrange)
        spectra.append(spect)
        
        cont.set_spectrum(spect, tt)
        
    context.container = cont    
    

#
# Given ...
#
@given('that I have a TwoDResponseContainer containing {N} spectra indexed by ValueAxis')
def step_given_25(context, N):
    """

        Given that I have a TwoDResponseContainer containing {N} spectra indexed by ValueAxis

    """

    _container(context, N, qr.ValueAxis)


#
# When ...
#
@when('I calculate Fourier transform on the container')
def step_when_26(context):
    """

        When I calculate Fourier transform on the container

    """
    cont = context.container

    new_cont = cont.fft(dtype=qr.signal_TOTL)

    context.new_container = new_cont

#
# Then ...
#
@then('I get correct pointwise Fourier transform of the spectra')
def step_then_27(context):
    """

        Then I get correct pointwise Fourier transform of the spectra

    """
    
    fft = context.new_container
    
    oldaxis = context.container.axis
    axis = fft.axis
    
    #
    # Asserting FFT of the data
    #
    
    # we pick several points where we test FFT 
    points = [[-10.0, 10.0], [0.0, 0.0], [0.0, 5.0], [5.0, -1]]
    
    cont = context.container
    for point in points:
        # time domain curve at a position in 2D spectrum 
        evol = cont.get_point_evolution(point[0], point[1], oldaxis)
        # Fourier transform of the time domain curve 
        fevol_direct = numpy.fft.ifft(evol.data)
        # at the same point in ffted container, we should get the same FFT 
        fevol_cont   = fft.get_point_evolution(point[0], point[1], axis)
        # assert equality
        numpy.testing.assert_allclose(fevol_direct, fevol_cont.data, atol=1.0e-10)
        
        
    

#
# And ...
#
@then('the TwoDResponse container will be indexed by ValueAxis with frequencies corresponding to the original ValueAxis')
def step_then_28(context):
    """

        And the TwoDResponse container will be indexed by ValueAxis with frequencies corresponding to the original ValueAxis

    """
    fft = context.new_container
    
    oldaxis = context.container.axis
    axis = fft.axis
    
    freq = (2.0*numpy.pi)*numpy.fft.fftfreq(oldaxis.length, oldaxis.step)
    freq = numpy.fft.fftshift(freq)
    
    # this has to be done to get desired precision 
    vax = qr.ValueAxis(freq[0], len(freq), freq[1]-freq[0])
    
    #
    # Asserting the value axis has the right values
    #
    numpy.testing.assert_allclose(axis.data, vax.data)


#
# Given ...
#
@given('that I have a TwoDResponseContainer containing {N} spectra indexed by TimeAxis')
def step_given_29(context, N):
    """

        Given that I have a TwoDResponseContainer containing {N} spectra indexed by TimeAxis

    """
    _container(context, N, qr.TimeAxis)


#
# And ...
#
@then('the TwoDResponse container will be indexed by FrequencyAxis which corresponds to the original TimeAxis')
def step_then_30(context):
    """

        And the TwoDResponse container will be indexed by FrequencyAxis which corresponds to the original TimeAxis

    """
    fft = context.new_container
    ori = context.container
    
    ori_fftaxis = ori.axis.get_FrequencyAxis()
    fft_axis = fft.axis
    
    assert ori_fftaxis == fft_axis


#
# Given ...
#
@given('that I have a TwoDResponseContainer containing {N} spectra indexed by FrequencyAxis')
def step_given_31(context, N):
    """

        Given that I have a TwoDResponseContainer containing {N} spectra indexed by FrequencyAxis

    """
    _container(context, N, qr.FrequencyAxis)


#
# And ...
#
@then('the TwoDResponse container will be indexed by TimeAxis which corresponds to the original FrequencyAxis')
def step_then_32(context):
    """

        And the TwoDResponse container will be indexed by TimeAxis which corresponds to the original FrequencyAxis

    """
    fft = context.new_container
    ori = context.container
    
    ori_fftaxis = ori.axis.get_TimeAxis()
    fft_axis = fft.axis
    
    assert ori_fftaxis == fft_axis
